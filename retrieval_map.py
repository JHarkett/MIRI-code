"""
Extracts spectra from a specified cube, converts to spx file units
(W/cm2/sr/um) and saves each spectrum in a seperate file within a
spectrum directory. Also a mapping file is generated for the later
assembly of the retrieved variables and the relevant coordinates
generated by make_RAdec.py are saved in the same spectral directory.

Usage:
		line 32: input dither position to use
		line 34: input name of file to process
		line 35: input name of corresponding mapping file (made using navigation2.py)
		line 37: input name of directory where data should be saved

		python - W ignore retrieval_map.py


"""

import numpy as np
from astropy.io import fits
import os

c = 2.99792458e+8
h=6.626e-34
k=1.3806e-23
c1=2*h*c*c
c2=(h*c)/k

#=======================================================================
#Inputs

dither = 'd1'

file = 'stage3/' + dither + '/Level3_ch2-long_s3d.fits'
map_file = 'stage3/' + dither + '_nav/Level3_ch2-long_s3d_nav.fits'

outfile = 'retrieval_data/ch2C_' + dither + '_spectra'

if not os.path.exists(outfile):
	os.mkdir(outfile)

#Wavelength range to use, set to outside the bounds of the data
#To use all of it
wmin = 1.0
wmax = 20.0


#======================================================================
#Functions


#Finds nearest array wavelength value to specified range
#Returns index of that wavelength
def find_nearest(array,value):
	array = np.asarray(array)
	idx = (np.abs(array - value)).argmin()
	return idx


#Converts surfbrightness to brightness T
def convert_TB(flux,wave):
	length = len(flux)

	flux12p = [None]*length
	v = [None]*length
	radiance_out = [None]*length
	TB_out = [None]*length
	a = [None]*length

	for i in range(length):

		v[i] = 1/(wave[i]*(1e-6))

		radiance_out[i] = (flux[i] * 1e-26) # Radiance in W/m2/sr/m-1
		radiance_out[i] = radiance_out[i] * c # Radiance in W/m2/sr/m$

		a[i] = (c1*v[i]*v[i]*v[i])/radiance_out[i]
		TB_out[i] = (c2*v[i])/np.log(a[i]+1)

	return TB_out


#Converts brightness T to spx file units
def convert_spx(TB,wave):
	l = wave * (1e-6)

	a=(2*h*c*c)/(pow(l,5))
	b = np.exp((h*c)/(l*k*TB)) - 1

	rad = a/b         # W/m2/sr/m
	rad = rad/(1e4)     # W/cm2/sr/m
	rad = rad/(1e6)     # W/cm2/sr/um

	return rad


#Generates txt files of the longitudes, latitudes and emission angles
def longlatemi_map(map_dir):
	hdu_long = fits.open(map_dir + '/longitude.fits')
	long_data = hdu_long[0].data
	hdu_lat = fits.open(map_dir + '/latitude.fits')
	lat_data = hdu_lat[0].data
	hdu_emission = fits.open(map_dir + '/emission.fits')
	emission_data = hdu_emission[0].data

	np.savetxt(outfile + '/post_longitudes.txt',long_data,fmt='%.6f',delimiter='	')
	np.savetxt(outfile + '/post_latitudes.txt',lat_data,fmt='%.6f',delimiter='	')
	np.savetxt(outfile + '/post_emission.txt',emission_data,fmt='%.6f',delimiter='	')

	

#=======================================================================
#Main

#Finds and opens cube
hdul1 = fits.open(file)
image = hdul1['SCI'].data
err = hdul1['ERR'].data
hdr = hdul1['SCI'].header
dq = hdul1['DQ'].data
hdul1.close()

hdul2 = fits.open(map_file)
lat_data = hdul2['LAT_PGR'].data
lon_data = hdul2['LON_WEST'].data
mu_data = hdul2['MU'].data
hdul2.close()

dz,dy,dx = image.shape

wavelist = np.arange(hdr['NAXIS3'])*hdr['CDELT3'] + hdr['CRVAL3']

idx_start = find_nearest(wavelist,wmin)
idx_stop = find_nearest(wavelist,wmax)

image_trimmed = image[idx_start:idx_stop+1]
err_trimmed = err[idx_start:idx_stop+1]
wave_trimmed = wavelist[idx_start:idx_stop+1]


#Checks if outfile exists, if not, it creates it
if not os.path.exists(outfile):
	os.mkdir(outfile)

length3 = len(image_trimmed)

#Removes 0 values from array and reshapes
for i in range(length3):
	for j in range(dy):
		for ii in range(dx):
			if not dq[0][j][ii] == 0:
				image_trimmed[i][j][ii] = np.nan

data_noblank = [None]*length3
err_noblank = [None]*length3
for i in range(length3):
	data_noblank[i] = image_trimmed[i][np.logical_not(np.isnan(image_trimmed[0]))]
	err_noblank[i] = err_trimmed[i][np.logical_not(np.isnan(image_trimmed[0]))]

id = np.arange(1,(dy*dx)+1)

d = np.reshape(id,(dy,dx))
hdu2 = fits.PrimaryHDU(d)
hdu2.writeto(outfile + '/retrieval_map.fits',overwrite=True)

id2 = d[np.logical_not(np.isnan(image_trimmed[0]))]
length_id2 = len(id2)
id2_number = np.arange(1,length_id2+1)

f = [None]*2
f[0] = id2_number
f[1] = id2

g = np.transpose(f)

hdu_dq2 = fits.PrimaryHDU(dq[0])
hdu_dq2.writeto(outfile + '/dq.fits',overwrite=True)

np.savetxt(outfile + '/id_conserve.txt',g,fmt='%.2f',delimiter='	',header='Pixel	Position')

data_noblankt = np.transpose(data_noblank)
err_noblankt = np.transpose(err_noblank)
length4 = len(data_noblankt)

TB = [None]*length4
TB_err = [None]*length4
flux = [None]*length4
flux_err = [None]*length4

for i in range(length4):
	data_noblankt[i][np.isnan(data_noblankt[i])] = 0.0
	err_noblankt[i][np.isnan(err_noblankt[i])] = 0.0
	data_noblankt[i] *= (1e+6)
	err_noblankt[i] *= (1e+6)
	TB[i] = convert_TB(data_noblankt[i],wave_trimmed)
	TB_err[i] = convert_TB(err_noblankt[i],wave_trimmed)
	flux[i] = convert_spx(TB[i],wave_trimmed)
	flux_err[i] = convert_spx(TB_err[i],wave_trimmed)

for i in range(length4):
	sa = [None]*3
	sa[0] = wave_trimmed
	sa[1] = flux[i]
	sa[2] = flux_err[i]

	st = np.transpose(sa)
	np.savetxt(outfile + '/{}_flux.txt'.format(i+1),st,fmt='%.6e',delimiter='	',header = 'Wavelength	R	R_err')


hdu_lat = fits.PrimaryHDU(lat_data)
hdu_lat.writeto(outfile + '/lat_pgr.fits',overwrite=True)

hdu_lat = fits.PrimaryHDU(lon_data)
hdu_lat.writeto(outfile + '/lon_west.fits',overwrite=True)


dym,dxm = mu_data.shape

for i in range(dym):
	for j in range(dxm):
		mu_data[i][j] = np.arccos(mu_data[i][j])
		mu_data[i][j] = (mu_data[i][j]*180)/np.pi


hdu_lat = fits.PrimaryHDU(mu_data)
hdu_lat.writeto(outfile + '/mu.fits',overwrite=True)



#=======================================================================


print('End of script\n')
